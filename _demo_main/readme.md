# Це приклад побудови http-сервера за допомогою punctum-бібліотеки 

## Ініціяція модулів

Модуль, який слід ініціювати при старті програми, ініціюється наступним чином:    
* модуль імплементує інтерфейс starter.Operator (з пакету starter);
* кожен інстанс starter.Operatorʼа надалі називатимемо "стартером"; 
* при запуску програми створюється слайс стартерів з додатковими параметрами, до якого, серед инших, додається стартер цього модуля (в прикладі це робиться в demo_config/starters
.go); 
* параметри, які додаються до кожного стартера, можуть бути специфічними; зокрема, стартер можна ініціювати декілька разів незалежно і з різними параметрами;   
* при старті програми робиться виклик starter.Run(), в процесі якого кожен стартер ініціюється послідовними викликами його методів .Prepare(), .Check() та .Init(); метод 
.Prepare() при цьому отримує і загальні config-параметри системи, і специфічні параметри ініціяції, згадані вище;
* якщо ж потрібно провести ініціяцію модуля пізніше або незалежно від загального списку інціяції, то це можливо зробити тими самими викликами, взявши окремий його стартер.

Методи starter.Operator'а:
* .Prepare() — прийом-обробка параметрів;
* .Check() - перевірка контексту (наприклад, структури таблиць в БД); 
* .Init() - власне, ініціяція модуля;
* .Setup() - корекція контексту (наприклад, створення таблиць в БД);
* .Name() - для позначення модуля в загальному списку і вибору його звідти (при передачі запуску з вибором модуля через консольні параметри, скажімо). 

Сценарії використання starter.Operator'а:
* при виклику starter.Run(): .Prepare(), потім, якщо все ок, то .Check(), потім, якщо все ок, то .Init();
* при сетап-викликах (вони поки відсутні в прикладі; це може бути, наприклад, ініціяція БД): .Prepare(), потім, якщо все ок, то .Setup();


## Звʼязність між частинами системи

В процесі ініціяції модуль може створювати обʼєкти, потрібні для роботи иншим модулям системи. Звичайним рішенням для забезпечення звʼязности є або створення таких обʼєктів 
публічними, або доступ до них публічними функціями (getters) модуля. Таке рішення є цілком простим і не потребує ніяких додаткових інструментів. Але воно (якщо без додаткових 
фінтів) підрозуміває, що модуль може створити тільки один обʼєкт певного типу — наприклад, інстанс доступу до БД. Натомість, щоб мати можливість ініціювати по декілька однотипних 
інстансів і звертатись до них по ключах, в цій системі реалізовано інтерфейс joiner.Operator (в joiner). В силу сказаного, цей інтерфейс, звісно, можна вважати 
"надлишковим" :-) З иншого боку, будь-які програмні бібліотеки будуться з урахуванням субʼєктивних преференцій їх авторів — от і в цьому прикладі, і в усіх модулях з використанням 
punctum-бібліотеки для звʼязности частин автором використовується саме інтерфейс joiner.Operator, а можливість прямих звертань між інстансами геть проіґнорована (таку побудову 
можна і арґументувати — але це вже не суть важливо).

Отже, звʼязність забезпечується наступним чином:
* функція starter.Run при виклику створює інстанс joiner.Operatorʼа;
* цей інстанс передається кожному стартеру при виклику метода .Init();
* стартер, який додає в систему певний обʼєкт, робить це викликом joiner.JoinInterface(ptr interface{}, key string);
* стартер, який запитує в системи деякий обʼєкт з певним ключем, робить це викликом joiner.Interface(key string);
* стартер, якому потрібні всі обʼєкти з певним ключем, отримує їх викликом joiner.ComponentsAll(key string);
* стартер, якому потрібні всі обʼєкти певного типу, отримує їх викликом ComponentsAllWithInterface(ptrToInterface interface{}).

Така схема підрозуміває, що в момент виклику метода .Init(), всі обʼєкти, потрібні цьому стартеру, вже додані в систему — отже, порядок стартерів при ініціяції має бути 
відповідним. Якби ж було потрібно викликати .Init() в той момент, коли якісь залежності для цього стартера ще не готові, то стартер може зберегти інстанс joinerʼа, отриманий ним 
при виклику, і звертатись до методів цього joiner'а пізніше.   